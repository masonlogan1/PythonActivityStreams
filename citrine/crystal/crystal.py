"""
Module for managing the Citrine.Crystal object

Citrine crystals are a form of semi-universal storage that find and latch
onto Property objects associated with a class. When an object is "crystallized"
(i.e. stored into a Citrine database) a ``Crystal`` object is created by
taking the value of all properties from the original object and storing them
as attributes. After the ``Crystal`` is created, the original object will have
the getter and setter attributes for all properties picked up during
crystallization pointed to the new persistent ``Crystal`` object. The original
functionality of the getters and setters will remain, however the source of
the data will be no longer be the internal state of the original object, it
will be the internal state of the persistent ``Crystal``.
"""

from persistent import Persistent

from jsonld.base import ContextualProperty

from citrine.crystal.cache import (
    save_to_crystallization_cache, save_to_decrystallization_cache,
    load_from_crystallization_cache, load_from_decrystallization_cache,
    crystallization_cache_has, decrystallization_cache_has
)


def property_override(crystal, prop, attr_name,
                      fget=False, fset=False, fdel=False):
    """
    Wrap an existing property's fset to update the crystal
    :param crystal: the new crystal overriding the old fset
    :param prop: the property to wrap
    :param attr_name: the name of the attribute
    :return: new ContextualProperty object wrapping the prior property
    """
    def fget_wrapper(old_fget):
        def crystal_fget(obj):
            return old_fget(obj)
        return crystal_fget

    def fset_wrapper(old_fset):
        def crystal_fset(obj, val):
            old_fset(obj, val)
            setattr(obj.__crystal__, attr_name, prop.fget(obj))
        return crystal_fset

    def fdel_wrapper(old_fdel):
        def crystal_fdel(obj):
            old_fdel(obj)
        return crystal_fdel

    new_prop = ContextualProperty(fget=fget_wrapper(prop.fget) if fget else prop.fget,
                                  fset=fset_wrapper(prop.fset) if fset else prop.fset,
                                  fdel=fdel_wrapper(prop.fdel) if fdel else prop.fdel,
                                  doc=prop.__doc__,
                                  name=attr_name)
    return new_prop


def property_from_attribute(attr_name, default=None):
    """
    Takes an attribute name and creates a property from it
    :param attr_name:
    :param default:
    :return:
    """
    attr_name = f'___{attr_name}___'

    def fget(obj):
        return getattr(obj, attr_name, default)

    def fset(obj, val):
        setattr(obj, attr_name, val)

    def fdel(obj):
        delattr(obj, attr_name)

    doc = f"autogenerated property for attribute '{attr_name}'"

    return ContextualProperty(fget=fget, fset=fset, fdel=fdel, doc=doc,
                              name=attr_name)


def crystal_init(self, crystal, **data):
    self.__crystal__ = crystal
    self.__base_init__(**data)


def create_decrystallization_class(
        crystal, cls, override=tuple(), prop_map=None, cache=True):
    """"""

    crystal_map = prop_map if prop_map else {}
    template_map = {value: key for key, value in crystal_map.items()}

    # find the available properties
    if hasattr(cls, '__properties__'):
        properties = {prop: getattr(cls, prop)
                      for prop in cls.__properties__}
    else:
        properties = {prop: getattr(cls, prop)
                      for prop in dir(cls)
                      if isinstance(getattr(cls, prop), property)}

    # convert override to list of all property names if override is True
    override = (override if override is not True else
                list(properties.keys()))

    # create overridden properties with vanilla fget/fset/fdel
    for name in override:
        properties[name] = property_from_attribute(
            crystal_map.get(name, name),
            default=getattr(crystal, name)
        )

    # create wrapped properties
    for name, prop in properties.items():
        if name in override:
            continue
        properties[name] = property_override(
            crystal, prop, template_map.get(name, name), fset=True)

    # create the new class
    new_class = type(cls.__name__, tuple(cls.mro()), dict(cls.__dict__))

    # modify the class to use the new dict of properties
    for name, prop in properties.items():
        setattr(new_class, crystal_map.get(name, name), prop)

    new_class.__base_init__ = new_class.__init__
    new_class.__init__ = crystal_init

    # save to cache (if applicable)
    if cache:
        save_to_decrystallization_cache(cls, new_class)

    return new_class


class Crystal(Persistent):
    """
    Persistent object that latches onto another object, gathers the data
    from its properties, stores itself to a database, and wraps the getter
    and setter methods for an object to replace, in part or whole, the internal
    state of the original object with itself.
    """
    # A good analogy for this object is like that fungus that takes over an
    # insect's mind and moves it around like a puppet. The crystal will rewire
    # the getters and setters for itself and change the underlying class,
    # essentially turning the original object into a puppet

    def __init__(self, **kwargs):
        # grab all kwarg values
        for key, value in kwargs.items():
            setattr(self, key, value)

    @classmethod
    def crystallize(cls, obj, attributes=tuple(), evaluate=True, override=True,
                    cache=True, refresh_cache=False):
        """
        Takes an object and converts it into a persistent ``Crystal``.

        if attributes are provided, attributes with the given names will be
        provided to the crystal

        if evaluate is True (default), the object will be scanned for properties
        and the values will be persisted

        if override is True (default), the object will be modified in-place,
        replacing the original class in favor of one with modified properties
        that update the persistent Crystal whenever the original object is
        modified

        if override is False, the original object will not be modified and the
        ``Crystal`` will NOT be updated alongside the original object

        If ``cache`` is True, cached classes in the module will be checked first
        for a match, and if one does not exist a new one will be created and
        saved to the cache. Otherwise, the new class will be created but not
        saved in the cache

        Modified objects will receive an ``update`` method along with an
        ``__autoupdate__`` attribute. When ``update`` is used, it will persist
        the latest copy of the object to the database. When ``__autoupdate__``
        is True, every change to the object will be immediately pushed to the
        database. ``__autoupdate__`` defaults to False.

        :param obj: the object to scan and potentially modify
        :param attributes: attribute names to persist
        :param evaluate: whether to scan for property values
        :param override: whether to modify the original object
        :return: ``Crystal`` object with desired information
        """

        # collect properties from the original object, if desired
        if evaluate:
            if hasattr(obj, '__properties__'):
                properties = {prop: getattr(obj.__class__, prop)
                              for prop in obj.__properties__}
            else:
                properties = {prop: getattr(obj.__class__, prop)
                              for prop in dir(obj)
                              if isinstance(getattr(obj, prop), property)}
        else:
            properties = dict()

        # get attribute+prop names and pair to object values
        values = {name: getattr(obj, name)
                  for name in list(attributes)+list(properties.keys())}

        # create the crystal
        new = cls(**values)

        # if override, alter the original object
        if override:
            # check the cache for an existing class
            if cache and not refresh_cache and crystallization_cache_has(
                    obj.__class__):
                new_class = load_from_crystallization_cache(obj.__class__)
                # change the object's class to the cached one
                obj.__class__ = new_class
                return new

            # this class will override the current class
            # TODO: CACHE CLASSES
            new_class = type(obj.__class__.__name__, tuple(obj.__class__.mro()),
                             dict(obj.__class__.__dict__))

            # any attributes specified should have a property made
            for attr in attributes:
                properties[attr] = property_from_attribute(attr, default=getattr(obj, attr))

            # override the SETTER values for an existing object
            for name, prop in properties.items():
                # if 'prop' is a property then override, otherwise make a new
                # property and set that on the new class
                new_prop = (property_override(new, prop, name, fset=True)
                            if isinstance(prop, property)
                            else property_from_attribute(name, default=prop))
                setattr(new_class, name, new_prop)

            # cache in case we need it again
            save_to_crystallization_cache(obj.__class__, new_class)

            # change the object's class to the newly manufactured one
            obj.__class__ = new_class

        return new

    def decrystallize(self, cls,
                      override=tuple(), prop_map=None, exclude=tuple(),
                      cache=True, refresh_cache=False):
        """
        Convert this object into a usable object with the provided class.

        Attributes of the ``Crystal`` will be mapped to properties on the class
        by altering the getter/setter values to use the persistent crystal as
        a source and automatically update the ``Crystal`` when object properties
        are also changed.

        ``args`` and ``kwargs`` are passed to the constructor of the class.
        If ``kwargs`` is True, all attributes of the Crystal will be passed in

        Any attributes of the ``Crystal`` specified by ``override`` will have
        the functionality of the class completely overridden by a standard
        getter/setter. If ``override`` is True, all properties of the class
        will have their functionality overridden by a standard getter/setter

        Override names are based on the names of the attributes in the
        ``Crystal``, not the template class

        If ``map`` is provided, it will map the names of attributes in the
        ``Crystal`` to the name of properties in the template class. Otherwise,
        properties will be mapped to attribute by name

        Any names in ``exclude`` will not be mapped to the new class, even if
        a property name exists. This will override anything in ``map``

        :param cls: class to use as a template for the object
        :param args: args to pass into the template constructor
        :param kwargs: keyword args to pass into the template constructor
        :param override: whether and which properties to fully replace with standard getter/setters
        :param cache: whether to use the cache
        :return:
        """

        data = {k: v for k, v in self.__dict__.items() if k not in exclude}

        if cache and not refresh_cache and decrystallization_cache_has(cls):
            new_class = load_from_decrystallization_cache(cls)
        else:
            new_class = create_decrystallization_class(
                self, cls, override, prop_map)

        return new_class(crystal=self, **data)
